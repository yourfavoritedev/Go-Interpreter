package vm

import (
	"fmt"

	"github.com/yourfavoritedev/golang-interpreter/code"
	"github.com/yourfavoritedev/golang-interpreter/compiler"
	"github.com/yourfavoritedev/golang-interpreter/object"
)

const StackSize = 10

// VM holds the constants and instructions generated by the compiler.
// A VM implements a stack to organize the items it will execute in a LIFO manner.
// The field sp helps keep track of the position of the next item in the stack (top to bottom).
type VM struct {
	constants    []object.Object
	instructions code.Instructions
	stack        []object.Object
	// sp always points to the next free slot in the stack. If there's one element on the stack,
	// located at index 0, the value of sp would be 1 and to access the element we'd use stack[sp-1].
	sp int
}

// New initializes a new VM using the bytecode generated by the compiler.
// VM's are initialized with an sp of 0 (the top of the stack). The stack
// will have a preallocated number of elements (StackSize).
func New(bytecode *compiler.Bytecode) *VM {
	return &VM{
		instructions: bytecode.Instructions,
		constants:    bytecode.Constants,
		stack:        make([]object.Object, StackSize),
		sp:           0,
	}
}

// Run will start the VM. The VM will execute the bytecode and handle
// the specific instructions (opcode + operands) that it was provided
// from the compiler. It executes the fetch-decode-execute cycle.
func (vm *VM) Run() error {
	// iterate across all bytecode instructions
	for ip := 0; ip < len(vm.instructions); ip++ {
		// FETCH the instruction (opcode + operand) at the specific position (ip, the instruction pointer)
		// then convert the instruction's first-byte into an Opcode (which is what we expect it to be)
		op := code.Opcode(vm.instructions[ip])
		// DECODE SECTION
		switch op {
		// OpConstant has an operand to decode
		case code.OpConstant:
			// grab the two-byte operand for the OpConstant instruction (the operand starts right after the Opcode byte)
			operand := vm.instructions[ip+1:]
			// decode the operand, getting back the identifier for the constant's position in the constants pool
			constIndex := code.ReadUint16(operand)
			// increment the instruction-pointer by 2 because OpConstant has one two-byte wide operand
			ip += 2
			// EXECUTE, grab the constant from the pool and push it on to the stack
			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}

		// OpAdd has no operands, but we need to execute the operation
		case code.OpAdd:
			// EXECUTE: pop the two constants from the stack and assert the Objects to grab their integer value
			right := vm.pop()
			left := vm.pop()
			leftValue := left.(*object.Integer).Value
			rightValue := right.(*object.Integer).Value

			result := leftValue + rightValue
			// push the summed Object to the stack
			vm.push(&object.Integer{Value: result})

		// OpPop has no operands and simply pops an element from the stack
		case code.OpPop:
			// EXECUTE: pop the element before the stack pointer
			vm.pop()
		}
	}

	return nil
}

// push validates the stack size and adds the provided object (o) to the
// next available slot in the stack, finally it preps the stackpointer (sp),
// incrementing it to designate the next slot to be allocated
func (vm *VM) push(o object.Object) error {
	if vm.sp >= StackSize {
		return fmt.Errorf("stack overflow")
	}

	vm.stack[vm.sp] = o
	vm.sp++

	return nil
}

// LastPoppedStackElem helps identify the last element that was popped from the stack as the VM executes through it.
// If a stack had two elements [a, b], sp would be at index 2. If the vm pops an element,
// it would pop the element at [sp-1], so index 1, and then sp is moved to index 1.
// Leaving b to be the last popped stack element.
func (vm *VM) LastPoppedStackElem() object.Object {
	return vm.stack[vm.sp]
}

// pop simply grabs the constant sittng 1 position above the stackpointer,
// it then decrements the stack pointer to be aware of the updated position,
// leaving that slot to be eventually overwritten with a new constant
func (vm *VM) pop() object.Object {
	o := vm.stack[vm.sp-1]
	vm.sp--
	return o
}
