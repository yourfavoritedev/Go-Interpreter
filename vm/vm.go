package vm

import (
	"fmt"

	"github.com/yourfavoritedev/golang-interpreter/code"
	"github.com/yourfavoritedev/golang-interpreter/compiler"
	"github.com/yourfavoritedev/golang-interpreter/object"
)

const StackSize = 2048

// VM holds the constants and instructions generated by the compiler.
// A VM implements a stack to organize the items it will execute in a LIFO manner.
// The field sp helps keep track of the position of the next item in the stack (top to bottom).
type VM struct {
	constants    []object.Object
	instructions code.Instructions
	stack        []object.Object
	sp           int // Always points to the next free slot in the stack. The "Top" of the stack is stack[sp-1]
}

// New initializes a new VM using the bytecode generated by the compiler.
// VM's are initialized with an sp of 0 (the top of the stack). The stack
// will have a preallocated number of elements (StackSize).
func New(bytecode *compiler.Bytecode) *VM {
	return &VM{
		instructions: bytecode.Instructions,
		constants:    bytecode.Constants,
		stack:        make([]object.Object, StackSize),
		sp:           0,
	}
}

// Run will start the VM. The VM will execute the bytecode and handle
// the specific instructions (opcode + operands) that it was provided
// from the compiler. It executes the fetch-decode-execute cycle.
func (vm *VM) Run() error {
	// iterate across all bytecode instructions
	for ip := 0; ip < len(vm.instructions); ip++ {
		// FETCH the instruction (opcode + operand) at the specific position (ip, the instruction pointer)
		// then convert the instruction's first-byte into an Opcode (which is what we expect it to be)
		op := code.Opcode(vm.instructions[ip])
		// DECODE SECTION
		switch op {
		// OpConstant has an operand to decode
		case code.OpConstant:
			// grab the two-byte operand for the OpConstant instruction (the operand starts right after the Opcode byte)
			operand := vm.instructions[ip+1:]
			// decode the operand, getting back the identifier for the constant's position in the constants pool
			constIndex := code.ReadUint16(operand)
			// increment the instruction-pointer by 2 because OpConstant has one two-byte wide operand
			ip += 2
			// EXECUTE, grab the constant from the pool and push it on to the stack
			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}
		// OpAdd has no operands, but we need to execute the operation
		case code.OpAdd:
			// EXECUTE: pop the two constants from the stack and assert the Objects to grab their integer value
			right := vm.pop()
			left := vm.pop()
			leftValue := left.(*object.Integer).Value
			rightValue := right.(*object.Integer).Value

			result := leftValue + rightValue
			// push the summed Object to the stack
			vm.push(&object.Integer{Value: result})
		}
	}

	return nil
}

// push validates the stack size and adds the provided object (o) to the
// next available slot in the stack, finally it preps the stackpointer (sp),
// incrementing it to designate the next slot to be allocated
func (vm *VM) push(o object.Object) error {
	if vm.sp >= StackSize {
		return fmt.Errorf("stack overflow")
	}

	vm.stack[vm.sp] = o
	vm.sp++

	return nil
}

// StackTop gets the object that is sitting on top of stack as the VM
// executes through it. (Note: as the VM goes through the stack, the top of the stack
// may not always be at index 0, the stack-pointer (p), which is the index of the top + 1
// will help us determine where the top is)
func (vm *VM) StackTop() object.Object {
	if vm.sp == 0 {
		return nil
	}

	return vm.stack[vm.sp-1]
}

// pop simply grabs the constant sittng at the current top position of the stack,
// leaving that slot to be eventually overwritten, it then decrements the stack pointer
// to be aware of the updated top position
func (vm *VM) pop() object.Object {
	o := vm.stack[vm.sp-1]
	vm.sp--
	return o
}
